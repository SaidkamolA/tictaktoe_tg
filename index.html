<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Крестики-нолики</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <h1>Крестики-нолики</h1>
    <div id="game-controls">
        <button id="create-game">Создать игру</button>
        <button id="show-join">Присоединиться к игре</button>
    </div>
    <div id="join-block" style="display:none;">
        <h2 style="margin-bottom:12px;font-size:1.15rem;font-weight:600;color:#6366f1;">Введите ID игры</h2>
        <input id="join-game-id-input" type="text" maxlength="36" placeholder="ID игры">
        <button class="join-btn" id="join-continue">Продолжить</button>
        <button class="back-btn" id="join-back">Назад</button>
    </div>
    <div id="game-id-show" style="display:none;"></div>
    <div id="status">Создайте или подключитесь к игре</div>
    <div id="players-row" class="players-row" style="display:none;">
        <div class="player player-x" id="player-x-name">Игрок 1</div>
        <div class="scoreboard-center" id="scoreboard-center">0 : 0</div>
        <div class="player player-o" id="player-o-name">Игрок 2</div>
    </div>
    <div id="board" style="display:none;"></div>
    <div id="move-timer" style="display:none;"></div>
    <button id="restart" style="display:none;">Сыграть ещё</button>
    <button id="ready-btn" style="display:none;">Готов к новой игре</button>
    <button id="exit-game-btn" style="display:none;">Выйти из игры</button>
    <div id="exit-modal" style="display:none;">
        <div>
            <h2>Выйти из игры?</h2>
            <div>
                <button id="exit-confirm-btn">Выйти</button>
                <button id="exit-cancel-btn">Отмена</button>
            </div>
        </div>
    </div>
    <canvas class="confetti" id="confetti-canvas" style="display:none;"></canvas>
    <div id="winner-banner" style="display:none;"></div>
    <div id="draw-banner" style="display:none;"></div>
    <div id="name-modal" style="display:none;">
        <div>
            <h2>Введите ваше имя</h2>
            <input id="player-name-input" type="text" maxlength="16">
            <button id="save-name-btn">Сохранить</button>
        </div>
    </div>

    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <script>
        // === Настройки ===
        const API_URL = "https://tictaktoe-back.onrender.com/api";

        // === Telegram User ===
        let tgUser = null;
        try {
            if (window.Telegram?.WebApp?.initDataUnsafe?.user?.id) {
                tgUser = Telegram.WebApp.initDataUnsafe.user;
            } else {
                tgUser = { id: 'test_' + Math.floor(Math.random() * 1000000), first_name: 'Гость' };
            }
            console.log('tgUser:', tgUser);
        } catch (e) {
            console.error('Ошибка инициализации Telegram WebApp:', e);
            tgUser = { id: 'test_' + Math.floor(Math.random() * 1000000), first_name: 'Гость' };
        }

        let telegramName = tgUser.first_name || tgUser.username || '';
        let playerName = telegramName || localStorage.getItem('ttt_player_name') || '';

        // === DOM ===
        const board = document.getElementById('board');
        const status = document.getElementById('status');
        const restartBtn = document.getElementById('restart');
        const createGameBtn = document.getElementById('create-game');
        const gameIdShow = document.getElementById('game-id-show');
        const gameControls = document.getElementById('game-controls');
        const playersRow = document.getElementById('players-row');
        const readyBtn = document.getElementById('ready-btn');
        const nameModal = document.getElementById('name-modal');
        const playerNameInput = document.getElementById('player-name-input');
        const saveNameBtn = document.getElementById('save-name-btn');
        const showJoinBtn = document.getElementById('show-join');
        const joinBlock = document.getElementById('join-block');
        const joinGameIdInput = document.getElementById('join-game-id-input');
        const joinContinueBtn = document.getElementById('join-continue');
        const joinBackBtn = document.getElementById('join-back');
        const playerXName = document.getElementById('player-x-name');
        const playerOName = document.getElementById('player-o-name');
        const scoreboardCenter = document.getElementById('scoreboard-center');
        const moveTimerDiv = document.getElementById('move-timer');
        const exitGameBtn = document.getElementById('exit-game-btn');
        const exitModal = document.getElementById('exit-modal');
        const exitConfirmBtn = document.getElementById('exit-confirm-btn');
        const exitCancelBtn = document.getElementById('exit-cancel-btn');
        const winnerBanner = document.getElementById('winner-banner');
        const drawBanner = document.getElementById('draw-banner');

        // === State ===
        let gameId = null;
        let playerSymbol = null;
        let boardState = [[null, null, null], [null, null, null], [null, null, null]];
        let current = 'X';
        let winner = null;
        let polling = null;
        let gameOver = false;
        let joined = false;
        let score_X = 0, score_O = 0, score_draw = 0;
        let ready_X = false, ready_O = false;
        let waitingReady = false;
        let moveTimer = null;
        let moveTimeout = 10;
        let moveTimerValue = moveTimeout;
        let prevMoveTurn = null;
        let winnerLine = null;
        let preStartTimer = null;
        let preStartValue = 3;
        let preStartLaunched = false;
        let lastWinner = null;

        // === Board Render ===
        function renderBoard() {
            board.innerHTML = '';
            for (let row = 0; row < 3; row++) {
                for (let col = 0; col < 3; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.setAttribute('data-symbol', boardState[row][col] || '');
                    cell.dataset.row = row;
                    cell.dataset.col = col;
                    if (!gameOver && playerSymbol && current === playerSymbol && !boardState[row][col] && !preStartTimer) {
                        cell.addEventListener('pointerdown', handleCellPointerDown, { passive: false });
                    }
                    board.appendChild(cell);
                }
            }
            if (winnerLine && winner) {
                drawWinLine(winnerLine);
            }
        }

        function handleCellPointerDown(e) {
            e.preventDefault();
            const row = parseInt(e.currentTarget.dataset.row, 10);
            const col = parseInt(e.currentTarget.dataset.col, 10);
            handleMove(row, col);
        }

        function renderScoreboard() {
            scoreboardCenter.textContent = `${score_X} : ${score_O}`;
            playerXName.textContent = (playerSymbol === 'X' && playerName) ? playerName : 'Игрок X';
            playerOName.textContent = (playerSymbol === 'O' && playerName) ? playerName : 'Игрок O';
        }

        function showGameUI(show) {
            playersRow.style.display = show ? 'flex' : 'none';
            board.style.display = show ? 'grid' : 'none';
            moveTimerDiv.style.display = show ? 'block' : 'none';
            exitGameBtn.style.display = show ? 'block' : 'none';
        }

        // === API ===
        async function apiCreateGame(userId) {
            try {
                const res = await fetch(`${API_URL}/new_game`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ user_id: userId })
                });
                if (!res.ok) throw new Error('Ошибка создания игры');
                return await res.json();
            } catch (e) {
                throw new Error('Не удалось создать игру. Проверьте соединение.');
            }
        }

        async function apiMove(gameId, row, col, symbol, userId) {
            try {
                const res = await fetch(`${API_URL}/move`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ game_id: gameId, row, col, symbol, user_id: userId })
                });
                if (!res.ok) {
                    const err = await res.json().catch(() => ({}));
                    throw new Error(err.detail || 'Ошибка хода');
                }
                return await res.json();
            } catch (e) {
                throw new Error('Не удалось выполнить ход. Проверьте соединение.');
            }
        }

        async function apiGetState(gameId, userId) {
            try {
                const res = await fetch(`${API_URL}/state/${gameId}?user_id=${userId}`);
                if (!res.ok) {
                    if (res.status === 404) {
                        resetToStart("Игра не найдена или завершена.");
                    }
                    throw new Error('Игра не найдена');
                }
                return await res.json();
            } catch (e) {
                throw new Error('Не удалось получить состояние игры.');
            }
        }

        async function apiReady(gameId, symbol) {
            try {
                const res = await fetch(`${API_URL}/ready`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ game_id: gameId, symbol })
                });
                if (!res.ok) {
                    const err = await res.json().catch(() => ({}));
                    throw new Error(err.detail || 'Ошибка готовности');
                }
                return await res.json();
            } catch (e) {
                throw new Error('Не удалось подтвердить готовность.');
            }
        }

        async function apiJoin(gameId, symbol, userId) {
            try {
                const res = await fetch(`${API_URL}/join`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ game_id: gameId, symbol, user_id: userId })
                });
                if (!res.ok) {
                    const err = await res.json().catch(() => ({}));
                    throw new Error(err.detail || 'Ошибка подключения');
                }
                return await res.json();
            } catch (e) {
                throw new Error('Не удалось присоединиться к игре.');
            }
        }

        // === Игровая логика ===
        function getPlayerSymbolForMove() {
            if (!tgUser || !tgUser.id) return playerSymbol;
            if (window.player_X_id && tgUser.id === window.player_X_id) return 'X';
            if (window.player_O_id && tgUser.id === window.player_O_id) return 'O';
            return playerSymbol;
        }

        async function handleMove(row, col) {
            if (gameOver || !playerSymbol || current !== playerSymbol || boardState[row][col] || preStartTimer) return;
            try {
                const symbol = getPlayerSymbolForMove();
                const data = await apiMove(gameId, row, col, symbol, tgUser.id);
                updateStateFromApi(data);
            } catch (e) {
                status.textContent = e.message;
            }
        }

        function updateStateFromApi(data) {
            playerSymbol = data.player_symbol;
            boardState = data.board;
            current = data.current;
            winner = data.winner;
            score_X = data.score_X ?? score_X;
            score_O = data.score_O ?? score_O;
            score_draw = data.score_draw ?? score_draw;
            ready_X = data.ready_X ?? false;
            ready_O = data.ready_O ?? false;
            gameOver = !!winner;
            winnerLine = data.winner_line || null;
            renderBoard();
            renderScoreboard();
            if (data.player_X_id) window.player_X_id = data.player_X_id;
            if (data.player_O_id) window.player_O_id = data.player_O_id;
            const connected_X = data.connected_X ?? true;
            const connected_O = data.connected_O ?? false;

            if (connected_X && connected_O && !gameOver && boardState.flat().every(cell => cell === null) && !winner && current === 'X' && !waitingReady) {
                if (!preStartTimer && !preStartLaunched) {
                    clearMoveTimer();
                    startPreStartTimer();
                }
                return;
            } else {
                clearPreStartTimer();
                preStartLaunched = false;
            }

            if (!gameOver && !winner && boardState.flat().some(cell => cell === null)) {
                if (current === playerSymbol) {
                    status.textContent = 'Ваш ход';
                    if (prevMoveTurn !== current) {
                        startMoveTimer();
                    }
                } else {
                    status.textContent = 'Ожидание соперника...';
                    clearMoveTimer();
                }
            } else if (winner === 'draw') {
                status.textContent = 'Ничья!';
                restartBtn.style.display = 'none';
                readyBtn.style.display = 'inline-block';
                waitingReady = true;
            } else if (winner) {
                status.textContent = `Победил: ${winner}`;
                restartBtn.style.display = 'none';
                readyBtn.style.display = 'inline-block';
                waitingReady = true;
            } else {
                status.textContent = 'Ожидание соперника...';
                clearMoveTimer();
            }

            if (waitingReady) {
                readyBtn.textContent = (playerSymbol === 'X' && ready_X) || (playerSymbol === 'O' && ready_O) ? 'Ожидание соперника...' : 'Готов к новой игре';
                readyBtn.disabled = (playerSymbol === 'X' && ready_X) || (playerSymbol === 'O' && ready_O);
            }

            if (!gameOver && current === playerSymbol && !winner && boardState.flat().some(cell => cell === null) && !preStartTimer && !preStartLaunched) {
                startMoveTimer();
            } else {
                clearMoveTimer();
            }

            prevMoveTurn = current;
            if (winner && winner !== 'draw' && lastWinner !== winner) {
                showWinnerBanner(winner);
                showConfetti();
            }
            if (winner === 'draw' && lastWinner !== 'draw') {
                showDrawBanner();
            }
            lastWinner = winner;
        }

        // === Пуллинг состояния ===
        function startPolling() {
            if (polling) clearInterval(polling);
            polling = setInterval(async () => {
                if (!gameId) return;
                try {
                    const data = await apiGetState(gameId, tgUser.id);
                    updateStateFromApi(data);
                } catch (e) {
                    console.error('Polling error:', e);
                }
            }, 1500);
        }

        function stopPolling() {
            if (polling) clearInterval(polling);
            polling = null;
        }

        // === UI: Создать/Подключиться ===
        createGameBtn.onclick = async () => {
            try {
                const data = await apiCreateGame(tgUser.id);
                gameId = data.game_id;
                await apiJoin(gameId, data.player_symbol, tgUser.id);
                updateStateFromApi(data);
                gameOver = false;
                joined = true;
                gameControls.style.display = 'none';
                gameIdShow.style.display = 'block';
                gameIdShow.textContent = `ID вашей игры: ${gameId}`;
                status.textContent = 'Ожидание соперника...';
                renderBoard();
                showGameUI(true);
                startPolling();
            } catch (e) {
                status.textContent = e.message;
            }
        };

        showJoinBtn.onclick = () => {
            gameControls.style.display = 'none';
            joinBlock.style.display = 'flex';
            joinGameIdInput.value = '';
            joinGameIdInput.focus();
        };

        joinBackBtn.onclick = () => {
            joinBlock.style.display = 'none';
            gameControls.style.display = 'flex';
        };

        joinContinueBtn.onclick = async () => {
            const id = joinGameIdInput.value.trim();
            if (!id) {
                status.textContent = 'Введите ID игры';
                return;
            }
            try {
                await apiJoin(id, 'O', tgUser.id);
                const data = await apiGetState(id, tgUser.id);
                gameId = id;
                updateStateFromApi(data);
                gameOver = !!winner;
                joined = true;
                joinBlock.style.display = 'none';
                gameIdShow.style.display = 'block';
                gameIdShow.textContent = `Вы подключились к игре: ${gameId}`;
                renderBoard();
                showGameUI(true);
                startPolling();
            } catch (e) {
                status.textContent = 'Игра не найдена';
            }
        };

        // === Рестарт ===
        restartBtn.onclick = () => {
            resetToStart('Создайте или подключитесь к игре');
        };

        readyBtn.onclick = async () => {
            try {
                const data = await apiReady(gameId, playerSymbol);
                updateStateFromApi(data);
            } catch (e) {
                status.textContent = e.message;
            }
        };

        // === Выход из игры ===
        exitGameBtn.onclick = () => {
            exitModal.style.display = 'flex';
        };

        exitCancelBtn.onclick = () => {
            exitModal.style.display = 'none';
        };

        exitConfirmBtn.onclick = () => {
            exitModal.style.display = 'none';
            resetToStart('Вы вышли из игры.');
        };

        // === Инициализация ===
        function askNameIfNeeded() {
            if (!playerName && !telegramName) {
                nameModal.style.display = 'flex';
                playerNameInput.focus();
            }
        }

        saveNameBtn.onclick = () => {
            const val = playerNameInput.value.trim();
            if (val.length < 2) {
                playerNameInput.style.borderColor = '#f87171';
                return;
            }
            playerName = val;
            localStorage.setItem('ttt_player_name', playerName);
            nameModal.style.display = 'none';
            renderScoreboard();
        };

        playerNameInput.oninput = () => {
            playerNameInput.style.borderColor = '#a5b4fc';
        };

        // === Конфетти ===
        function showConfetti() {
            const canvas = document.getElementById('confetti-canvas');
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            canvas.style.display = 'block';
            const ctx = canvas.getContext('2d');
            const confettiCount = 100; // Уменьшено для производительности
            const confetti = [];
            for (let i = 0; i < confettiCount; i++) {
                confetti.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * -canvas.height,
                    r: 5 + Math.random() * 5,
                    d: 6 + Math.random() * 6,
                    color: `hsl(${Math.random() * 360}, 80%, 60%)`,
                    tilt: Math.random() * 10 - 5,
                    tiltAngle: 0,
                    tiltAngleIncremental: (Math.random() * 0.05) + 0.03
                });
            }
            let frame = 0;
            function draw() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                for (let i = 0; i < confetti.length; i++) {
                    let c = confetti[i];
                    c.y += (Math.cos(frame * 0.01 + c.d) + 1 + c.r / 2) * 0.5;
                    c.x += Math.sin(frame * 0.01) * 0.5;
                    c.tiltAngle += c.tiltAngleIncremental;
                    c.tilt = Math.sin(c.tiltAngle) * 10;
                    ctx.beginPath();
                    ctx.lineWidth = c.r;
                    ctx.strokeStyle = c.color;
                    ctx.moveTo(c.x + c.tilt + c.r / 3, c.y);
                    ctx.lineTo(c.x + c.tilt, c.y + c.d);
                    ctx.stroke();
                }
                frame++;
                if (frame < 80) {
                    requestAnimationFrame(draw);
                } else {
                    canvas.style.display = 'none';
                }
            }
            draw();
        }

        function showWinnerBanner(winner) {
            let winnerText = `Победил: ${winner} 🎉`;
            if (playerSymbol === winner && (telegramName || playerName)) {
                winnerText = `Победил: ${telegramName || playerName} (${winner}) 🎉`;
            }
            winnerBanner.textContent = winnerText;
            winnerBanner.style.display = 'block';
            setTimeout(() => { winnerBanner.style.display = 'none'; }, 3000);
        }

        function showDrawBanner() {
            drawBanner.textContent = 'Ничья! 🤝';
            drawBanner.style.display = 'block';
            setTimeout(() => { drawBanner.style.display = 'none'; }, 3000);
        }

        // === Таймеры ===
        function startMoveTimer() {
            clearMoveTimer();
            moveTimerValue = moveTimeout;
            if (!playerSymbol || !gameId || current !== playerSymbol || gameOver) {
                moveTimerDiv.textContent = '';
                return;
            }
            moveTimerDiv.textContent = `Ваш ход: ${moveTimerValue} сек.`;
            moveTimer = setInterval(() => {
                moveTimerValue--;
                moveTimerDiv.textContent = `Ваш ход: ${moveTimerValue} сек.`;
                if (moveTimerValue <= 0) {
                    clearMoveTimer();
                    loseByTimeout();
                }
            }, 1000);
        }

        function clearMoveTimer() {
            if (moveTimer) {
                clearInterval(moveTimer);
                moveTimer = null;
            }
            moveTimerDiv.textContent = '';
        }

        function loseByTimeout() {
            winner = playerSymbol === 'X' ? 'O' : 'X';
            status.textContent = `Время вышло! Победил: ${winner}`;
            showWinnerBanner(winner);
            showConfetti();
            if (winner === 'X') score_X++;
            if (winner === 'O') score_O++;
            renderScoreboard();
            gameOver = true;
            readyBtn.style.display = 'inline-block';
            waitingReady = true;
        }

        function startPreStartTimer() {
            preStartValue = 3;
            moveTimerDiv.textContent = `Игра начнётся через ${preStartValue} сек.`;
            moveTimerDiv.style.display = 'block';
            preStartTimer = setInterval(() => {
                preStartValue--;
                moveTimerDiv.textContent = `Игра начнётся через ${preStartValue} сек.`;
                if (preStartValue <= 0) {
                    clearPreStartTimer();
                    preStartLaunched = true;
                    moveTimerDiv.textContent = '';
                    renderBoard();
                    startMoveTimer();
                }
            }, 1000);
        }

        function clearPreStartTimer() {
            if (preStartTimer) {
                clearInterval(preStartTimer);
                preStartTimer = null;
            }
        }

        // === Линия победы ===
        function drawWinLine(line) {
            const cellSize = board.clientWidth / 3 - 14; // Учитываем gap
            const offset = 14; // padding board
            const x1 = offset + line[0][1] * (cellSize + 14) + cellSize / 2;
            const y1 = offset + line[0][0] * (cellSize + 14) + cellSize / 2;
            const x2 = offset + line[1][1] * (cellSize + 14) + cellSize / 2;
            const y2 = offset + line[1][0] * (cellSize + 14) + cellSize / 2;
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('width', board.clientWidth);
            svg.setAttribute('height', board.clientHeight);
            svg.style.position = 'absolute';
            svg.style.left = '0';
            svg.style.top = '0';
            svg.style.pointerEvents = 'none';
            svg.style.zIndex = '10';
            const lineEl = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            lineEl.setAttribute('x1', x1);
            lineEl.setAttribute('y1', y1);
            lineEl.setAttribute('x2', x2);
            lineEl.setAttribute('y2', y2);
            lineEl.setAttribute('stroke', winner === 'X' ? '#38bdf8' : '#f472b6');
            lineEl.setAttribute('stroke-width', '8');
            lineEl.setAttribute('stroke-linecap', 'round');
            lineEl.style.opacity = '0.9';
            svg.appendChild(lineEl);
            board.appendChild(svg);
        }

        // === Сброс игры ===
        function resetToStart(msg) {
            stopPolling();
            gameId = null;
            playerSymbol = null;
            boardState = [[null, null, null], [null, null, null], [null, null, null]];
            current = 'X';
            winner = null;
            gameOver = false;
            joined = false;
            score_X = 0;
            score_O = 0;
            score_draw = 0;
            ready_X = false;
            ready_O = false;
            waitingReady = false;
            gameControls.style.display = 'flex';
            gameIdShow.style.display = 'none';
            status.textContent = msg || 'Создайте или подключитесь к игре';
            restartBtn.style.display = 'none';
            readyBtn.style.display = 'none';
            renderBoard();
            renderScoreboard();
            showGameUI(false);
            clearMoveTimer();
            clearPreStartTimer();
        }

        // === Инициализация ===
        window.addEventListener('DOMContentLoaded', () => {
            if (playerName) playerNameInput.value = playerName;
            askNameIfNeeded();
            renderBoard();
            renderScoreboard();
            showGameUI(false);
            try {
                Telegram.WebApp.expand();
            } catch (e) {
                console.error('Ошибка вызова Telegram.WebApp.expand:', e);
            }
        });
    </script>
</body>
</html>
